// Copyright (c) ktsu.dev
// All rights reserved.
// Licensed under the MIT license.
// <auto-generated />

#pragma warning disable IDE0040 // Accessibility modifiers required
#pragma warning disable CA2225 // Operator overloads have named alternates

namespace ktsu.Semantics.Quantities;

using System;
using System.Numerics;

/// <summary>
/// 4D vector representation of Acceleration.
/// </summary>
/// <typeparam name="T">The numeric component type.</typeparam>
public record Acceleration4D<T> : IVector4<Acceleration4D<T>, T>
	where T : struct, INumber<T>
{
	/// <summary>Gets the X component.</summary>
	public T X { get; init; }

	/// <summary>Gets the Y component.</summary>
	public T Y { get; init; }

	/// <summary>Gets the Z component.</summary>
	public T Z { get; init; }

	/// <summary>Gets the W component.</summary>
	public T W { get; init; }

	/// <summary>Gets a vector with all components set to zero.</summary>
	public static Acceleration4D<T> Zero => new() { X = T.Zero, Y = T.Zero, Z = T.Zero, W = T.Zero };

	/// <summary>Gets a vector with all components set to one.</summary>
	public static Acceleration4D<T> One => new() { X = T.One, Y = T.One, Z = T.One, W = T.One };

	/// <summary>Gets the unit vector for the X-axis.</summary>
	public static Acceleration4D<T> UnitX => new() { X = T.One, Y = T.Zero, Z = T.Zero, W = T.Zero };

	/// <summary>Gets the unit vector for the Y-axis.</summary>
	public static Acceleration4D<T> UnitY => new() { X = T.Zero, Y = T.One, Z = T.Zero, W = T.Zero };

	/// <summary>Gets the unit vector for the Z-axis.</summary>
	public static Acceleration4D<T> UnitZ => new() { X = T.Zero, Y = T.Zero, Z = T.One, W = T.Zero };

	/// <summary>Gets the unit vector for the W-axis.</summary>
	public static Acceleration4D<T> UnitW => new() { X = T.Zero, Y = T.Zero, Z = T.Zero, W = T.One };

	/// <summary>Gets the magnitude as a <see cref="AccelerationMagnitude{T}"/>.</summary>
	public AccelerationMagnitude<T> Magnitude() => AccelerationMagnitude<T>.Create(Length());

	/// <summary>Calculates the length of the vector.</summary>
	public T Length()
	{
		T sum = (X * X) + (Y * Y) + (Z * Z) + (W * W);
		double asDouble = double.CreateChecked(sum);
		return T.CreateChecked(Math.Sqrt(asDouble));
	}

	/// <summary>Calculates the squared length of the vector.</summary>
	public T LengthSquared() => (X * X) + (Y * Y) + (Z * Z) + (W * W);

	/// <summary>Calculates the dot product of two vectors.</summary>
	public T Dot(Acceleration4D<T> other) => (X * other.X) + (Y * other.Y) + (Z * other.Z) + (W * other.W);

	/// <summary>Calculates the distance between two vectors.</summary>
	public T Distance(Acceleration4D<T> other)
	{
		T dX = X - other.X;
		T dY = Y - other.Y;
		T dZ = Z - other.Z;
		T dW = W - other.W;
		T sum = (dX * dX) + (dY * dY) + (dZ * dZ) + (dW * dW);
		double asDouble = double.CreateChecked(sum);
		return T.CreateChecked(Math.Sqrt(asDouble));
	}

	/// <summary>Calculates the squared distance between two vectors.</summary>
	public T DistanceSquared(Acceleration4D<T> other)
	{
		T dX = X - other.X;
		T dY = Y - other.Y;
		T dZ = Z - other.Z;
		T dW = W - other.W;
		return (dX * dX) + (dY * dY) + (dZ * dZ) + (dW * dW);
	}

	/// <summary>Returns a normalized version of the vector.</summary>
	public Acceleration4D<T> Normalize()
	{
		T len = Length();
		return new() { X = X / len, Y = Y / len, Z = Z / len, W = W / len };
	}

	/// <summary>Adds two vectors.</summary>
	public static Acceleration4D<T> operator +(Acceleration4D<T> left, Acceleration4D<T> right) => new() { X = left.X + right.X, Y = left.Y + right.Y, Z = left.Z + right.Z, W = left.W + right.W };

	/// <summary>Subtracts two vectors.</summary>
	public static Acceleration4D<T> operator -(Acceleration4D<T> left, Acceleration4D<T> right) => new() { X = left.X - right.X, Y = left.Y - right.Y, Z = left.Z - right.Z, W = left.W - right.W };

	/// <summary>Multiplies a vector by a scalar.</summary>
	public static Acceleration4D<T> operator *(Acceleration4D<T> vector, T scalar) => new() { X = vector.X * scalar, Y = vector.Y * scalar, Z = vector.Z * scalar, W = vector.W * scalar };

	/// <summary>Multiplies a scalar by a vector.</summary>
	public static Acceleration4D<T> operator *(T scalar, Acceleration4D<T> vector) => new() { X = scalar * vector.X, Y = scalar * vector.Y, Z = scalar * vector.Z, W = scalar * vector.W };

	/// <summary>Divides a vector by a scalar.</summary>
	public static Acceleration4D<T> operator /(Acceleration4D<T> vector, T scalar) => new() { X = vector.X / scalar, Y = vector.Y / scalar, Z = vector.Z / scalar, W = vector.W / scalar };

	/// <summary>Negates a vector.</summary>
	public static Acceleration4D<T> operator -(Acceleration4D<T> vector) => new() { X = -vector.X, Y = -vector.Y, Z = -vector.Z, W = -vector.W };
	/// <summary>Acceleration4D * Duration = Velocity4D.</summary>
	public static Velocity4D<T> operator *(Acceleration4D<T> left, Duration<T> right) => new() { X = left.X * right.Value, Y = left.Y * right.Value, Z = left.Z * right.Value, W = left.W * right.Value };

	/// <summary>Acceleration4D / Duration = Jerk4D.</summary>
	public static Jerk4D<T> operator /(Acceleration4D<T> left, Duration<T> right) => new() { X = left.X / right.Value, Y = left.Y / right.Value, Z = left.Z / right.Value, W = left.W / right.Value };

};
