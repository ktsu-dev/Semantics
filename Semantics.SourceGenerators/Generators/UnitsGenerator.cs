// Copyright (c) ktsu.dev
// All rights reserved.
// Licensed under the MIT license.

namespace Semantics.SourceGenerators;

using System.Linq;
using System.Text;
using System.Text.Json;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Semantics.SourceGenerators.Models;

/// <summary>
/// Source generator that creates the Units.cs file from JSON metadata.
/// </summary>
[Generator]
public class UnitsGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find the units metadata JSON file
		IncrementalValuesProvider<string> metadataFiles = context.AdditionalTextsProvider
			.Where(file => file.Path.EndsWith("units.json", System.StringComparison.InvariantCulture))
			.Select((file, cancellationToken) => file.GetText(cancellationToken)?.ToString() ?? "")
			.Where(content => !string.IsNullOrEmpty(content));

		// Generate code from metadata
		context.RegisterSourceOutput(metadataFiles, (ctx, jsonContent) =>
		{
			if (string.IsNullOrEmpty(jsonContent))
			{
				return;
			}

			try
			{
				JsonSerializerOptions options = new()
				{
					PropertyNameCaseInsensitive = true
				};

				UnitsMetadata metadata = JsonSerializer.Deserialize<UnitsMetadata>(jsonContent, options) ??
					throw new JsonException("Failed to deserialize units metadata");

				if (metadata?.UnitCategories == null)
				{
					return;
				}

				// Generate the Units.cs source code
				string sourceCode = GenerateUnitsClass(metadata);

				// Add the generated source to the compilation
				ctx.AddSource("Units.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
			}
			catch (JsonException ex)
			{
				// Report JSON parsing error
				DiagnosticDescriptor descriptor = new(
					"UNITS001",
					"JSON parsing error",
					"Failed to parse units metadata JSON: {0}",
					"SourceGenerator",
					DiagnosticSeverity.Error,
					isEnabledByDefault: true);

				ctx.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, ex.Message));
			}
		});
	}

	private static string GenerateUnitsClass(UnitsMetadata metadata)
	{
		StringBuilder builder = new();

		builder.AppendLine("// Copyright (c) ktsu.dev");
		builder.AppendLine("// All rights reserved.");
		builder.AppendLine("// Licensed under the MIT license.");
		builder.AppendLine("// <auto-generated />");
		builder.AppendLine();
		builder.AppendLine("namespace ktsu.Semantics;");
		builder.AppendLine();
		builder.AppendLine("/// <summary>");
		builder.AppendLine("/// Unit information record");
		builder.AppendLine("/// </summary>");
		builder.AppendLine("public record UnitInfo(string Name, string Symbol, string System, string Magnitude = \"\", string ConversionFactor = \"\", string Offset = \"\");");
		builder.AppendLine();
		builder.AppendLine("/// <summary>");
		builder.AppendLine("/// Static registry of commonly used units organized by physical domain.");
		builder.AppendLine("/// </summary>");
		builder.AppendLine("public static class Units");
		builder.AppendLine("{");

		// Group units by category for better organization
		IOrderedEnumerable<UnitCategory> groupedUnits = metadata.UnitCategories.OrderBy(c => c.Name);

		foreach (UnitCategory category in groupedUnits)
		{
			if (category.Name != "General")
			{
				builder.AppendLine();
				builder.AppendLine($"\t// === {category.Name.ToUpperInvariant()} ===");
				builder.AppendLine();
			}

			foreach (UnitDefinition unit in category.Units.OrderBy(u => u.Name))
			{
				GenerateUnitProperty(builder, unit);
			}
		}

		builder.AppendLine("}");
		return builder.ToString();
	}

	private static void GenerateUnitProperty(StringBuilder builder, UnitDefinition unit)
	{
		// Generate XML documentation
		builder.AppendLine($"\t/// <summary>{unit.Description}</summary>");

		// Generate the property declaration with available data
		builder.AppendLine($"\tpublic static readonly UnitInfo {unit.Name} = new(");
		builder.AppendLine($"\t\tname: \"{unit.Name}\",");
		builder.AppendLine($"\t\tsymbol: \"{unit.Symbol}\",");
		builder.AppendLine($"\t\tsystem: \"{unit.System}\"");

		// Add optional properties if they exist
		if (!string.IsNullOrEmpty(unit.Magnitude))
		{
			builder.AppendLine($"\t\t, magnitude: \"{unit.Magnitude}\"");
		}

		if (!string.IsNullOrEmpty(unit.ConversionFactor))
		{
			builder.AppendLine($"\t\t, conversionFactor: \"{unit.ConversionFactor}\"");
		}

		if (!string.IsNullOrEmpty(unit.Offset))
		{
			builder.AppendLine($"\t\t, offset: \"{unit.Offset}\"");
		}

		builder.AppendLine("\t);");
		builder.AppendLine();
	}
}
