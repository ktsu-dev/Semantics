// Copyright (c) ktsu.dev
// All rights reserved.
// Licensed under the MIT license.

namespace Semantics.SourceGenerators;

using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Semantics.SourceGenerators.Models;

/// <summary>
/// Source generator that creates the PhysicalDimensions.cs file from JSON metadata.
/// </summary>
[Generator]
public class DimensionsGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find the dimensions metadata JSON file
		IncrementalValuesProvider<string> metadataFiles = context.AdditionalTextsProvider
			.Where(file => file.Path.EndsWith("dimensions.json", System.StringComparison.InvariantCulture))
			.Select((file, cancellationToken) => file.GetText(cancellationToken)?.ToString() ?? "")
			.Where(content => !string.IsNullOrEmpty(content));

		// Generate code from metadata
		context.RegisterSourceOutput(metadataFiles, (ctx, jsonContent) =>
		{
			if (string.IsNullOrEmpty(jsonContent))
			{
				return;
			}

			try
			{
				JsonSerializerOptions options = new()
				{
					PropertyNameCaseInsensitive = true
				};

				DimensionsMetadata metadata = JsonSerializer.Deserialize<DimensionsMetadata>(jsonContent, options) ??
					throw new JsonException("Failed to deserialize units metadata");

				if (metadata?.PhysicalDimensions == null)
				{
					return;
				}

				// Generate the PhysicalDimensions.cs source code
				string sourceCode = GeneratePhysicalDimensionsClass(metadata);

				// Add the generated source to the compilation
				ctx.AddSource("PhysicalDimensions.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
			}
			catch (JsonException ex)
			{
				// Report JSON parsing error
				DiagnosticDescriptor descriptor = new(
					"DIMS001",
					"JSON parsing error",
					"Failed to parse dimensions metadata JSON: {0}",
					"SourceGenerator",
					DiagnosticSeverity.Error,
					isEnabledByDefault: true);

				ctx.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, ex.Message));
			}
		});
	}

	private static string GeneratePhysicalDimensionsClass(DimensionsMetadata metadata)
	{
		StringBuilder builder = new();

		builder.AppendLine("// Copyright (c) ktsu.dev");
		builder.AppendLine("// All rights reserved.");
		builder.AppendLine("// Licensed under the MIT license.");
		builder.AppendLine("// <auto-generated />");
		builder.AppendLine();
		builder.AppendLine("namespace ktsu.Semantics;");
		builder.AppendLine();
		builder.AppendLine("using System.Collections.Generic;");
		builder.AppendLine("using System.Collections.Frozen;");
		builder.AppendLine();
		builder.AppendLine("/// <summary>");
		builder.AppendLine("/// Dimension information record");
		builder.AppendLine("/// </summary>");
		builder.AppendLine("public record DimensionInfo(string Name, string Symbol, Dictionary<string, int> DimensionalFormula, List<string> Quantities);");
		builder.AppendLine();
		builder.AppendLine("/// <summary>");
		builder.AppendLine("/// Static registry of physical dimensions.");
		builder.AppendLine("/// </summary>");
		builder.AppendLine("public static class PhysicalDimensions");
		builder.AppendLine("{");

		// Group dimensions by category for better organization
		IOrderedEnumerable<PhysicalDimension> groupedDimensions = metadata.PhysicalDimensions.OrderBy(d => d.Name);

		foreach (PhysicalDimension dimension in groupedDimensions)
		{
			GenerateDimensionProperty(builder, dimension);
		}

		// Generate the All property
		builder.AppendLine();
		builder.AppendLine("\t/// <summary>Gets a frozen collection of all standard physical dimensions.</summary>");
		builder.AppendLine("\tpublic static FrozenSet<DimensionInfo> All { get; } = new HashSet<DimensionInfo>(");
		builder.AppendLine("\t\t[");

		IOrderedEnumerable<PhysicalDimension> allDimensions = metadata.PhysicalDimensions.OrderBy(d => d.Name);
		foreach (PhysicalDimension dimension in allDimensions)
		{
			builder.AppendLine($"\t\t\t{dimension.Name},");
		}

		builder.AppendLine("\t\t]).ToFrozenSet();");
		builder.AppendLine("}");

		return builder.ToString();
	}

	private static void GenerateDimensionProperty(StringBuilder builder, PhysicalDimension dimension)
	{
		// Generate XML documentation - use first quantity's description or dimension name
		string description = dimension.Quantities.FirstOrDefault()?.Description ?? $"Physical dimension: {dimension.Name}";
		builder.AppendLine($"\t/// <summary>{description}</summary>");

		// Generate a dimension info record with the available data
		builder.AppendLine($"\tpublic static readonly DimensionInfo {dimension.Name} = new(");
		builder.AppendLine($"\t\tName: \"{dimension.Name}\",");
		builder.AppendLine($"\t\tSymbol: \"{dimension.Symbol}\",");

		// Add dimensional formula
		if (dimension.DimensionalFormula.Count > 0)
		{
			builder.AppendLine($"\t\tDimensionalFormula: new Dictionary<string, int> {{");
			foreach (KeyValuePair<string, int> kvp in dimension.DimensionalFormula)
			{
				string dimensionName = kvp.Key;
				int exponent = kvp.Value;
				builder.AppendLine($"\t\t\t[\"{dimensionName}\"] = {exponent},");
			}
			builder.AppendLine($"\t\t}},");
		}
		else
		{
			builder.AppendLine($"\t\tDimensionalFormula: new Dictionary<string, int>(),");
		}

		// Add quantities
		if (dimension.Quantities.Count > 0)
		{
			builder.AppendLine($"\t\tQuantities: new List<string> {{ {string.Join(", ", dimension.Quantities.Select(q => $"\"{q.Name}\""))} }}");
		}
		else
		{
			builder.AppendLine($"\t\tQuantities: new List<string>()");
		}

		builder.AppendLine("\t);");
		builder.AppendLine();
	}
}
