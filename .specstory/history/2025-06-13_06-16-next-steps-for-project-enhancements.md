<!-- Generated by SpecStory -->

# Next steps for project enhancements (2025-06-13 16:16:04)

_**User**_

Immediate Next Steps (Priority Order):
1. üìã Update Documentation & Status
Since all domains are complete, we should:
Update the README.md to reflect the completed status
Update docs/complete-library-guide.md with all implemented domains
Ensure all references point to docs/examples/ (not examples/)
Create comprehensive usage examples for each domain
2. üîç Code Quality & Standards Review
Perform a systematic review to ensure all domains meet the standards:
Verify all quantities use PhysicalConstants.Generic methods
Check for any remaining hard-coded values
Ensure all XML documentation is complete and accurate
Verify mathematical relationships are properly implemented
3. üß™ Enhanced Testing Strategy
Building on our comprehensive physical constants tests:
Integration Tests: Create tests that use quantities from multiple domains together
Performance Benchmarks: Add benchmarks for common operations
Mathematical Verification: Expand tests for physics relationships across domains
Edge Case Coverage: Ensure robust error handling
4. ‚ö° Performance & Optimization
Add performance benchmarks for unit conversions and arithmetic operations
Profile memory usage and optimize if needed
Consider adding more efficient calculation paths for common operations
5. üìñ Advanced Documentation
Create domain-specific guides with real-world examples
Add physics relationship documentation showing how quantities interact
Create migration guides for users coming from other physics libraries
Add troubleshooting and FAQ sections
6. üîß Developer Experience Improvements
Consider adding more convenience methods for common calculations
Implement additional operator overloads where physics relationships warrant them
Add more descriptive error messages and validation

---

_**Assistant**_



---

I'll help you work through these priority items systematically. Let me start by examining the current state of the project to understand what needs to be updated.

---

Read file: README.md

---

<details>
            <summary>Listed directory docs ‚Ä¢ **8** results</summary>
        
| Name |
|-------|
| üìÅ `examples` |
| üìÑ `design-semantic-quantities.md` |
| üìÑ `complete-library-guide.md` |
| üìÑ `library-overview.md` |
| üìÑ `architecture.md` |
| üìÑ `fluent-validation-integration.md` |
| üìÑ `validation-reference.md` |
| üìÑ `advanced-usage.md` |

</details>

---

<details>
            <summary>Searched codebase "complete-library-guide.md" ‚Ä¢ **1** results</summary>
        
| File |
|------|
| `undefined` |

</details>

---

Read file: docs/complete-library-guide.md

---

Now let me examine the Semantics/Quantities directory structure to understand what domains are implemented:

---

<details>
            <summary>Listed directory Semantics/Quantities ‚Ä¢ **9** results</summary>
        
| Name |
|-------|
| üìÅ `FluidDynamics` |
| üìÅ `Core` |
| üìÅ `Acoustic` |
| üìÅ `Nuclear` |
| üìÅ `Optical` |
| üìÅ `Mechanics` |
| üìÅ `Chemical` |
| üìÅ `Thermal` |
| üìÅ `Electrical` |

</details>

---

<details>
            <summary>Listed directory docs/examples ‚Ä¢ **10** results</summary>
        
| Name |
|-------|
| üìÑ `PhysicsRelationshipExamples.md` |
| üìÑ `examples-index.md` |
| üìÑ `path-handling.md` |
| üìÑ `validation-attributes.md` |
| üìÑ `real-world-scenarios.md` |
| üìÑ `advanced-validation.md` |
| üìÑ `factory-pattern.md` |
| üìÑ `string-operations.md` |
| üìÑ `type-conversions.md` |
| üìÑ `getting-started.md` |

</details>

---

<details>
            <summary>Searched codebase "PhysicalConstants.Generic methods quantity domains" ‚Ä¢ **19** results</summary>
        
| File | Lines |
|------|-------|
| `Semantics/Quantities/Core/PhysicalConstants.cs` | L163-211 |
| `Semantics/Quantities/Core/PhysicalConstants.cs` | L268-302 |
| `Semantics/Quantities/Core/PhysicalConstants.cs` | L211-241 |
| `Semantics/Quantities/Core/PhysicalQuantity.cs` | L1-50 |
| `docs/design-semantic-quantities.md` | L94-150 |
| `Semantics/Quantities/Chemical/AmountOfSubstance.cs` | L1-41 |
| `.cursor/rules/derived-cursor-rules.mdc` | L78-90 |
| `Semantics/Quantities/Core/IPhysicalQuantity.cs` | L1-28 |
| `Semantics/Quantities/Core/PhysicalDimensions.cs` | L317-411 |
| `Semantics/Quantities/Thermal/Heat.cs` | L1-57 |
| `Semantics/Quantities/Core/PhysicalDimensions.cs` | L27-59 |
| `Semantics/Quantities/Core/PhysicalDimensions.cs` | L89-119 |
| `Semantics/Quantities/Thermal/Temperature.cs` | L1-44 |
| `Semantics.Test/PhysicalConstantsTests.cs` | L208-254 |
| `Semantics/TODO_DOMAINS.md` | L111-153 |
| `Semantics/Quantities/Core/PhysicalConstants.cs` | L302-327 |
| `Semantics/Quantities/Core/PhysicalConstants.cs` | L52-110 |
| `Semantics/Quantities/Chemical/RateConstant.cs` | L1-42 |
| `Semantics/Quantities/Acoustic/Frequency.cs` | L53-101 |

</details>

---

Let me fetch the relevant rules to understand the project context better:

---

### Rule: derived-cursor-rules

**AI rules derived by SpecStory from the project AI interaction history**

```markdown
## Headers

This file defines all project rules, coding standards, workflow guidelines, references, documentation structures, and best practices for the AI coding assistant. It is a living document that evolves with new user‚ÄìAI interactions.

## TECH STACK

(Additions to the tech stack are recorded here, including new coding tools or libraries.)

*   FluentValidation

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

(Information about project documentation, context, and version changes are recorded here.)

*   Create a `docs` directory for technical documentation.
*   Move technical information from the `README` file into appropriate documents within the `docs` directory.
*   Move the content from the architecture document into an appropriate document within the `docs` directory.
*   Add documentation about the path interface hierarchy to both the architecture documentation and examples.
*   Put examples in documents, not in code.
*   **Ensure the documentation is correct.**
*   The primary problem is that the **README.md file refers to an `examples/` directory at the root level, but the examples are actually located in `docs/examples/`**. All references in `README.md` to the `examples/` directory should be updated to `docs/examples/`.
*   The architecture documentation should accurately reflect the actual class hierarchy implementation.
*   The validation reference documentation should be comprehensive and accurate, including newer validation attributes.
*   Update the `README.md` and `docs/` to describe the whole library.
*   Create a `docs/complete-library-guide.md` file to provide a comprehensive overview of all features and components in the ktsu.Semantics library.
*   Before we continue implementing more domains, search the quantities, units, and dimensions for hard coded values that should be defined as physical constants and define them somewhere appropriate. Add this to the TODO document as part of the implementation guidelines.
*   Apply the constants in any appropriate calculations in the quantities units and dimensions, you may define derived constants as well and create unit tests comparing the constant derived values vs calculated derived values using the fundamental constants
*   **Management Rules for Physical Constants:**
    1.  Use `PhysicalConstants.Generic` methods for type-safe access
    2.  Add new constants to `PhysicalConstants.cs` before using them
    3.  Refactor existing hard-coded values when implementing new domains
    4.  Document constant sources (CODATA, NIST, ISO/IEC)
*   Before we continue implementing more domains, search the quantities, units, and dimensions for hard coded values that should be defined as physical constants and define them somewhere appropriate. Add this to the TODO document as part of the implementation guidelines
*   Apply the constants in any appropriate calculations in the quantities units and dimensions, you may define derived constants as well and create unit tests comparing the constant derived values vs calculated derived values using the fundamental constants
*   **Management Rules for Physical Constants:**
    1.  Use `PhysicalConstants.Generic` methods for type-safe access
    2.  Add new constants to `PhysicalConstants.cs` before using them
    3.  Refactor existing hard-coded values when implementing new domains
    4.  Document constant sources (CODATA, NIST, ISO/IEC)

When adding XML documentation comments:

*   Ensure comprehensive `<summary>` tags are included for all public types and members.
*   Use detailed `<remarks>` sections to explain usage patterns and important details.
*   Include proper `<param>` and `<returns>` documentation for methods.
*   Use `<exception>` documentation for potential exceptions.
*   Incorporate `<see cref="">` for cross-references.
*   Use detailed `<list>` elements for enumerated information.
*   Follow Microsoft's documentation standards.
*   Remove all of the example documentation from the XML comments.
*   **Domain Implementation Workflow**
    1.  Use the Chemical domain as a template.
    2.  Before coding, search for any hard-coded constants and add them to `PhysicalConstants.cs`.
    3.  Implement quantities with full unit conversions and dimensional analysis.
    4.  Add comprehensive unit tests, including mathematical relationship checks.
    5.  Document all new quantities and constants.
*   **Always centralize physical constants** in `PhysicalConstants.cs` before using them in any domain.
*   **Use type-safe generic accessors** for all constants.
*   **Refactor any hard-coded values** found in new or existing code.
*   **Document all sources** for constants (CODATA, NIST, ISO/IEC).
*   **Follow the established code and documentation standards** (file headers, XML docs, null safety, generic constraints).
*   **Test thoroughly**: unit tests, mathematical verification, integration tests.
*   **Mechanical Domain Implementation (Highest Priority)**
    *   Implement quantities like Force, Energy, Power, Pressure, etc., with full unit conversions and dimensional analysis.
    *   Add comprehensive unit tests, including mathematical relationship checks (e.g., F = m¬∑a, P = F/A, E = F¬∑d).
    *   Document all new quantities and constants.
*   **Integration Tests**
    *   Create tests that use quantities from multiple domains in calculations.
    *   Verify that units and conversions work seamlessly across domains.
*   **Performance Benchmarks**
    *   Add benchmarks for common operations (e.g., unit conversions, arithmetic).
    *   Optimize as needed.
*   **Documentation Expansion**
    *   Update the `docs/complete-library-guide.md` with new domains and features.
    *   Add usage examples for new quantities.
    *   Ensure all references in `README.md` and other docs are accurate (e.g., `docs/examples/`).
*   **Implementation Plan and Tracker**
    *   **Physical Constants First**: Identify all mechanical constants needed (e.g., gravitational acceleration, standard atmospheric pressure, Planck‚Äôs constant if needed for mechanics, etc.). Add them to `PhysicalConstants.cs` under appropriate categories (Fundamental, Mechanical, etc.). Use the `PhysicalConstants.Generic` pattern for type-safe access. Include XML docs and source references (CODATA, NIST, etc.).
    *   **Define Quantities**:
        *   Location: `Quantities/Mechanics/`
        *   Quantities to Implement: Force (`Force.cs`), Pressure (`Pressure.cs`), Energy (`Energy.cs`), Power (`Power.cs`), Torque (`Torque.cs`), Momentum (`Momentum.cs`), AngularVelocity (`AngularVelocity.cs`), AngularAcceleration (`AngularAcceleration.cs`), MomentOfInertia (`MomentOfInertia.cs`), Density (`Density.cs`), SpecificGravity (`SpecificGravity.cs`), and any others listed in your TODOs. Follow the template from the Chemical domain (generic, type-safe, XML docs, unit conversions, etc.).
    *   **Units and Dimensions**: For each quantity, define the SI and common units in `Units.cs`. Add or update `PhysicalDimensions.cs` as needed for new dimensions (e.g., force, energy).
    *   **Mathematical Relationships**: Implement relationships (e.g., F = m¬∑a, P = F/A, E = F¬∑d) as static methods or extension methods. Add unit tests to verify these relationships using both constants and calculated values.
    *   **Testing**: For each quantity: Create unit tests for creation, conversion, and validation. Add mathematical verification tests (e.g., compare calculated force to expected value). Add edge case and error handling tests.
    *   **Documentation**: Update or create: XML docs for all new types and members. Update `docs/complete-library-guide.md` with new mechanical quantities and usage examples. Update `README.md` and any references to examples (ensure they point to `docs/examples/`).
    *   **Integration and Performance**: Create tests that use both chemical and mechanical quantities together (e.g., energy calculations involving moles and force). Add benchmarks for common operations (unit conversions, arithmetic, etc.).
    *   **Review and Refactor**: As you implement, refactor any hard-coded values found in other domains to use the new constants. Ensure all code follows the standards (headers, null safety, XML docs, etc.).
    *   **Next Domains**: After Mechanical, move to Electromagnetic, then Thermal, then Optical, Acoustic, Nuclear, and Fluid Dynamics, following the same process.
*   When a file is missing the standard header, add the following to the top of the file:
```csharp
// Copyright (c) KTSU. All rights reserved.
```
*   `Semantics/TODO_DOMAINS.md` should now serve as the single, authoritative implementation plan and progress tracker, combining all domain status, next steps, code standards, and actionable checklists.
*   `Semantics/IMPLEMENTATION_SUMMARY.md` should simply point to `TODO_DOMAINS.md` and state that all planning and status are now tracked there.
*   **Implementation Process for All Domains:**
    1.  For each quantity listed in the tracker:
        *   Check if the file exists and review its implementation.
        *   Ensure it follows the standards: generic, type-safe, XML docs, uses centralized constants, no hard-coded values, proper units/dimensions, and has tests.
        *   If compliant, mark as implemented in the tracker.
        *   If not, note what‚Äôs missing for future action.
    2.  Update the tracker after each quantity/domain review.
*   **Systematic Review and Update Process for All Domains:**
    1.  **For Each Domain (Mechanical, Electrical, Thermal, etc.):**
        *   For each quantity listed in the tracker:
            *   Check if the file exists and review its implementation.
            *   Ensure it follows the standards: generic, type-safe, XML docs, uses centralized constants, no hard-coded values, proper units/dimensions, and has tests.
            *   If compliant, mark as implemented in the tracker.
            *   If not, note what‚Äôs missing for future action.
    2.  Update the tracker after each quantity/domain review.
*   **Implementation Summary**
    *   **COMPLETED DOMAINS:**
        1.  **Chemical** (10/10 quantities)
        2.  **Mechanical** (15/15 quantities)
        3.  **Electrical** (11/11 quantities)
        4.  **Thermal** (10/10 quantities)
        5.  **Acoustic** (20/20 quantities)
        6.  **Nuclear** (5/5 quantities)
        7.  **Optical** (6/6 quantities)
        8.  **Fluid Dynamics** (5/5 quantities)
    *   **REMAINING DOMAINS:**
        *   None
*   Missing friendly method alternates are not required for operators that define integral/derivative relationships, they can be suppressed with an attribute using:
```csharp
[System.Diagnostics.CodeAnalysis.SuppressMessage("Major Code Smell", "CA2225:Provide named alternates for operator overloads", Justification = "Physics relationship operators represent fundamental equations, not arithmetic")]
```
*   When performing integrations/derivations and both sides of the operation are physical quantities, they will both already be stored in the SI base unit for their physical dimension, so we dont need to convert them back to concrete numeric types before doing the operation, until the formula depends on a culculation thats not in an SI base unit.
*   When performing integrations/derivations and both sides of the operation are physical quantities, they will both already be stored in the SI base unit for their physical dimension, so we dont need to convert them back to concrete numeric types before doing the operation. Even further than that, you can use the multiply and divide operators on the PhysicalQuantity derived types directly.
*   When implementing physics relationships:
    *   Use the `.Value` property directly instead of performing unit conversions.
    *   Suppress CA2225 warnings using `[System.Diagnostics.CodeAnalysis.SuppressMessage("Major Code Smell", "CA2225:Provide named alternates for operator overloads", Justification = "Physics relationship operators represent fundamental equations, not arithmetic")]`.
    *   The dimensional analysis infrastructure exists in `PhysicalDimension` and base classes, but the specific physics relationships need systematic implementation across all quantity types.
    *   The current implementation lacks the fundamental integration and derivative relationships that should be expressed through `*` and `/` operators.
*   When `Force * Length` could be interpreted as energy or torque, making these calls ambiguous with the same parameters but a different return type:
    *   Keep the more fundamental relationship (work/energy) as an operator.
    *   Use an explicit method for torque.
*   When a test fails update it to use the new operator syntax instead of the removed `FromForceAndArea` method.
*   When creating PhysicalDimensions:
    *   Replace all `Units.` references in `PhysicalDimensions.cs` with the corresponding `Bootstrap` units.
*   When working with dimensionless quantities:
    *   Reserve Radians for Angular Quantities Only
    *   Create Semantically Appropriate Dimensionless Units. For example, use BootstrapDimensionless, BootstrapDecibel and BootstrapPH for non-angular dimensionless quantities.
*   **Testing Physical Constants:** Add additional tests for physical constants to validate stored values against calculated values from fundamental constants.
*   **Testing Physical Constants - Validation Chain**: Where any of the constants can be derived from fundamental constants or other derived constants, they should be tested in that fashion to make sure they are as accurate as possible through all stages of calculation.```

---

Based on my analysis of the project, I can see that all the physics domains are actually complete according to the TODO_DOMAINS.md file. Now let me work through the priority items systematically:

## Priority 1: üìã Update Documentation & Status

Let me start by updating the README.md to reflect the completed status and fix the examples path references:

---

Read file: README.md

---



---

Now I'll update the README.md to reflect the completed status of all physics domains and add the comprehensive physics capabilities:

---



---



---



---



---



---

Now let me add a comprehensive physics domains section to the README:

---



---



---

Now let me fix the examples path references throughout the README:

---



---



---

Now let me update the complete library guide to reflect all the implemented domains:

---

Read file: docs/complete-library-guide.md

---



---

Now let me update the complete library guide to include the comprehensive physics domains:

---



---



---



---



---

Now let me update the summary at the end of the document to reflect the completed status:

---



---



---

Now let me create comprehensive usage examples for each domain. Let me first check what currently exists:

---

Read file: docs/examples/PhysicsRelationshipExamples.md

---



---

Good! The physics examples are already comprehensive. Now let me move to Priority 2: Code Quality & Standards Review. Let me check for any remaining hard-coded values across the domains:

---

<details>
            <summary>Grep search for "\b\d+\.\d+\b" ‚Ä¢ **2** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L25 | `const double expected = 42.0;` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L51 | `const double expected = 10.0;` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L65 | `Distance distance1 = Distance.Create(10.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L66 | `Distance distance2 = Distance.Create(5.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L72 | `Assert.AreEqual(15.0, sum.Quantity);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L79 | `Distance distance1 = Distance.Create(10.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L80 | `Distance distance2 = Distance.Create(3.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L86 | `Assert.AreEqual(7.0, difference.Quantity);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L93 | `Distance distance = Distance.Create(5.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L99 | `Assert.AreEqual(-5.0, negated.Quantity);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L106 | `Distance distance = Distance.Create(10.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L107 | `const double factor = 2.5;` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L113 | `Assert.AreEqual(25.0, product.Quantity);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L120 | `Distance distance = Distance.Create(20.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L121 | `const double divisor = 4.0;` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L127 | `Assert.AreEqual(5.0, quotient.Quantity);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L134 | `Distance distance1 = Distance.Create(20.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L135 | `Distance distance2 = Distance.Create(5.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L141 | `Assert.AreEqual(4.0, ratio);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L156 | `Assert.AreEqual(15.0, sum.Quantity);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L170 | `Assert.AreEqual(8.0, difference.Quantity);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L178 | `Time time = Time.Create(0.5);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L184 | `Assert.AreEqual(50.0, speed.Quantity);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L192 | `const double factor = 3.0;` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L198 | `Assert.AreEqual(30.0, result.Quantity);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L212 | `Assert.AreEqual(4.0, speed.Quantity);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L220 | `const double divisor = 5.0;` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L226 | `Assert.AreEqual(10.0, result.Quantity);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L240 | `Assert.AreEqual(5.0, ratio);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L253 | `SemanticQuantity<Distance, double>.Add<Distance>(nullDistance!, Distance.Create(1.0)));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L260 | `const double expectedValue = 42.5;` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L271 | `Distance distance1 = Distance.Create(10.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L272 | `Distance distance2 = Distance.Create(10.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L283 | `Distance distance1 = Distance.Create(10.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L284 | `Distance distance2 = Distance.Create(15.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L295 | `Distance distance = Distance.Create(123.45);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L301 | `Assert.AreEqual("123.45", result);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L308 | `Distance distance = Distance.Create(50.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L314 | `Assert.AreEqual(50.0, value);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L321 | `Distance distance1 = Distance.Create(10.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L322 | `Distance distance2 = Distance.Create(10.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L332 | `Distance distance = Distance.Create(10.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L333 | `Distance zero = Distance.Create(0.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L338 | `Assert.AreEqual(zero, distance * 0.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L345 | `Distance positive = Distance.Create(10.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L346 | `Distance negative = Distance.Create(-5.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L353 | `Assert.AreEqual(5.0, sum.Quantity);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L354 | `Assert.AreEqual(15.0, difference.Quantity);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L361 | `Distance distance = Distance.Create(10.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L364 | `Assert.ThrowsExactly<DivideByZeroException>(() => distance / 0.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L371 | `Distance smaller = Distance.Create(5.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L372 | `Distance larger = Distance.Create(10.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L373 | `Distance equal = Distance.Create(5.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L385 | `Distance distance1 = Distance.Create(5.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L386 | `Distance distance2 = Distance.Create(10.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L387 | `Distance distance3 = Distance.Create(5.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L404 | `Distance distance = Distance.Create(100.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L405 | `Time time = Time.Create(20.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/SemanticQuantityTests.cs` | L411 | `Assert.AreEqual(5.0, speed.Quantity);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L20 | `double pressure = 101325.0;` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L44 | `double calculatedLn2 = Math.Log(2.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L53 | `double calculatedLn10 = Math.Log(10.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L77 | `Assert.AreEqual(1.0, product, Tolerance,` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L85 | `Assert.AreEqual(0.5, PhysicalConstants.Mathematical.OneHalf, Tolerance,` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L86 | `"One half should equal 0.5");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L88 | `Assert.AreEqual(2.0 / 3.0, PhysicalConstants.Mathematical.TwoThirds, Tolerance,` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L91 | `Assert.AreEqual(1.5, PhysicalConstants.Mathematical.ThreeHalves, Tolerance,` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L92 | `"Three halves should equal 1.5");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L94 | `Assert.AreEqual(4.0 / 3.0, PhysicalConstants.Mathematical.FourThirds, Tolerance,` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L105 | `Assert.AreEqual(9.0 / 5.0, celsiusToFahrenheitSlope, Tolerance,` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L108 | `Assert.AreEqual(5.0 / 9.0, fahrenheitToCelsiusSlope, Tolerance,` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L113 | `Assert.AreEqual(1.0, product, Tolerance,` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L122 | `double expectedKwHToJ = 1000.0 * 3600.0; // 1 kW = 1000 W, 1 hour = 3600 s` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L143 | `Assert.IsTrue(calculatedPoundForce is > 4.4 and < 4.5,` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L144 | `"Pound-force should be approximately 4.448 N");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L170 | `Assert.IsTrue(calculatedMolarMass is > 0.9 and < 1.1,` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L201 | `Assert.AreEqual(100.0, boilingCelsius, Tolerance,` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L208 | `Assert.AreEqual(0.01, triplePointCelsius, Tolerance,` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L209 | `"Water triple point should be 0.01¬∞C");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L262 | `double epsilon0 = 1.0 / (mu0 * c * c); // Permittivity of free space` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L277 | `// Should be approximately 1.602 √ó 10‚Åª¬π‚Åπ J` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L279 | `"1 eV should be approximately 1.602 √ó 10‚Åª¬π‚Åπ J");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L287 | `// Bohr radius should be approximately 5.29 √ó 10‚Åª¬π¬π m` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L290 | `double fineStructureConstant = 1.0 / 137.036; // Approximate value` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L293 | `// a‚ÇÄ ‚âà ‚Ñèc/(m‚Çëc¬≤Œ±) where m‚Çëc¬≤ ‚âà 0.511 MeV` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L298 | `// Should be approximately 5.3 √ó 10‚Åª¬π¬π m` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L300 | `"Bohr radius should be approximately 5.3 √ó 10‚Åª¬π¬π m");` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L307 | `// Should be approximately 2.82 √ó 10‚Åª¬π‚Åµ m` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L311 | `double epsilon0 = 1.0 / (mu0 * c * c);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L312 | `double electronRestMassEnergy = 0.511e6 * elementaryCharge; // 0.511 MeV in joules` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L317 | `// Should be approximately 2.8 √ó 10‚Åª¬π‚Åµ m` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics.Test/PhysicalConstantsTests.cs` | L319 | `"Classical electron radius should be approximately 2.8 √ó 10‚Åª¬π‚Åµ m");` |

</details>

---



---

Let me check for hard-coded values specifically in the quantity implementations (not tests):

---

<details>
            <summary>Grep search for "\b\d+\.\d+\b" ‚Ä¢ **24** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalResistance.cs` | L36 | `Create(fahrenheitHourPerBtu * T.CreateChecked(1.8956));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalResistance.cs` | L48 | `public T ToFahrenheitHourPerBtu() => Value / T.CreateChecked(1.8956);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalExpansion.cs` | L43 | `Create(perFahrenheit * T.CreateChecked(1.8));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalExpansion.cs` | L55 | `public T PerFahrenheit => Value / T.CreateChecked(1.8);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalExpansion.cs` | L101 | `/// <summary>Aluminum: 23.1 √ó 10‚Åª‚Å∂ K‚Åª¬π</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalExpansion.cs` | L104 | `/// <summary>Steel: 11.0 √ó 10‚Åª‚Å∂ K‚Åª¬π</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalExpansion.cs` | L107 | `/// <summary>Copper: 16.5 √ó 10‚Åª‚Å∂ K‚Åª¬π</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalExpansion.cs` | L110 | `/// <summary>Concrete: 10.0 √ó 10‚Åª‚Å∂ K‚Åª¬π</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalExpansion.cs` | L113 | `/// <summary>Glass: 9.0 √ó 10‚Åª‚Å∂ K‚Åª¬π</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalExpansion.cs` | L116 | `/// <summary>PVC: 52.0 √ó 10‚Åª‚Å∂ K‚Åª¬π</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalDiffusivity.cs` | L117 | `/// <summary>Water: 1.43 √ó 10‚Åª‚Å∑ m¬≤/s</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalDiffusivity.cs` | L120 | `/// <summary>Air: 2.2 √ó 10‚Åª‚Åµ m¬≤/s</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalDiffusivity.cs` | L123 | `/// <summary>Aluminum: 9.7 √ó 10‚Åª‚Åµ m¬≤/s</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalDiffusivity.cs` | L126 | `/// <summary>Steel: 1.2 √ó 10‚Åª‚Åµ m¬≤/s</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalDiffusivity.cs` | L129 | `/// <summary>Copper: 1.11 √ó 10‚Åª‚Å¥ m¬≤/s</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalDiffusivity.cs` | L132 | `/// <summary>Concrete: 5.0 √ó 10‚Åª‚Å∑ m¬≤/s</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/ThermalDiffusivity.cs` | L135 | `/// <summary>Glass: 3.4 √ó 10‚Åª‚Å∑ m¬≤/s</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/Temperature.cs` | L82 | `/// Calculates water freezing point (273.15 K, 0¬∞C).` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/Temperature.cs` | L88 | `/// Calculates water boiling point (373.15 K, 100¬∞C).` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/SpecificHeat.cs` | L44 | `Create(btuPerPoundFahrenheit * T.CreateChecked(4186.8));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/SpecificHeat.cs` | L56 | `public T BtuPerPoundFahrenheit => Value / T.CreateChecked(4186.8);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/HeatTransferCoefficient.cs` | L36 | `Create(btuPerHourSquareFootFahrenheit * T.CreateChecked(5.678));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/HeatTransferCoefficient.cs` | L52 | `public T BtuPerHourSquareFootFahrenheit => Value / T.CreateChecked(5.678);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/HeatCapacity.cs` | L36 | `Create(caloriesPerKelvin * T.CreateChecked(4.184));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/HeatCapacity.cs` | L44 | `Create(btuPerFahrenheit * T.CreateChecked(1899.1));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/HeatCapacity.cs` | L52 | `public T CaloriesPerKelvin => Value / T.CreateChecked(4.184);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/HeatCapacity.cs` | L56 | `public T BtuPerFahrenheit => Value / T.CreateChecked(1899.1);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/Entropy.cs` | L36 | `Create(caloriesPerKelvin * T.CreateChecked(4.184));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/Entropy.cs` | L44 | `Create(btuPerRankine * T.CreateChecked(1899.1));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/Entropy.cs` | L52 | `public T CaloriesPerKelvin => Value / T.CreateChecked(4.184);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Thermal/Entropy.cs` | L56 | `public T BtuPerRankine => Value / T.CreateChecked(1899.1);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Optical/RefractiveIndex.cs` | L28 | `/// <summary>Creates a refractive index for vacuum (n = 1.0 exactly).</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Optical/RefractiveIndex.cs` | L32 | `/// <summary>Creates a refractive index for air at standard conditions (n ‚âà 1.000293).</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Optical/RefractiveIndex.cs` | L34 | `public static RefractiveIndex<T> Air() => Create(T.CreateChecked(1.000293));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Optical/RefractiveIndex.cs` | L36 | `/// <summary>Creates a refractive index for water at 20¬∞C (n ‚âà 1.333).</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Optical/RefractiveIndex.cs` | L38 | `public static RefractiveIndex<T> Water() => Create(T.CreateChecked(1.333));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Optical/RefractiveIndex.cs` | L40 | `/// <summary>Creates a refractive index for crown glass (n ‚âà 1.52).</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Optical/RefractiveIndex.cs` | L42 | `public static RefractiveIndex<T> CrownGlass() => Create(T.CreateChecked(1.52));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Optical/RefractiveIndex.cs` | L44 | `/// <summary>Creates a refractive index for diamond (n ‚âà 2.42).</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Optical/RefractiveIndex.cs` | L46 | `public static RefractiveIndex<T> Diamond() => Create(T.CreateChecked(2.42));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Optical/Luminance.cs` | L38 | `T candelaPerSquareMeter = footLamberts * T.CreateChecked(3.426);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Optical/Illuminance.cs` | L33 | `T lux = footCandles * T.CreateChecked(10.764);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/RadioactiveActivity.cs` | L106 | `T halfLife = T.CreateChecked(Math.Log(2.0)) / decayConstant;` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/RadioactiveActivity.cs` | L129 | `T decayFactor = T.CreateChecked(Math.Pow(0.5, double.CreateChecked(exponent)));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/NuclearCrossSection.cs` | L155 | `T lowerBound = T.CreateChecked(0.001); // 1 millibarn` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/NuclearCrossSection.cs` | L156 | `T upperBound = T.CreateChecked(10.0);   // 10 barns` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/NuclearCrossSection.cs` | L165 | `T threshold = T.CreateChecked(0.001); // 1 millibarn` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/Exposure.cs` | L132 | `/// Uses the conversion factor: 1 R ‚âà 0.00876 Gy in air` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/Exposure.cs` | L139 | `T doseGray = exposureRoentgens * T.CreateChecked(0.00876);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/EquivalentDose.cs` | L33 | `T sieverts = rems * T.CreateChecked(0.01);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/EquivalentDose.cs` | L133 | `T limit = T.CreateChecked(0.02); // 20 mSv in Sv` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/EquivalentDose.cs` | L142 | `T limit = T.CreateChecked(0.001); // 1 mSv in Sv` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/AbsorbedDose.cs` | L33 | `T grays = rads * T.CreateChecked(0.01);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/AbsorbedDose.cs` | L152 | `/// - 0.25 Gy: Mild radiation sickness` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/AbsorbedDose.cs` | L160 | `T lethalThreshold = T.CreateChecked(4.0); // 4 Gy LD50` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/AbsorbedDose.cs` | L165 | `/// <returns>True if the dose exceeds 0.25 Gy.</returns>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Nuclear/AbsorbedDose.cs` | L169 | `T threshold = T.CreateChecked(0.25); // 0.25 Gy threshold for symptoms` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Mechanics/Force.cs` | L53 | `/// <returns>The weight force under standard gravity (9.80665 m/s¬≤).</returns>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Mechanics/Energy.cs` | L98 | `T two = T.CreateChecked(2.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Mechanics/Energy.cs` | L205 | `T twoValue = T.CreateChecked(2.0);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/VolumetricFlowRate.cs` | L33 | `T cubicMetersPerSecond = litersPerSecond * T.CreateChecked(0.001);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/VolumetricFlowRate.cs` | L42 | `T cubicMetersPerSecond = litersPerMinute * T.CreateChecked(0.001 / 60);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/VolumetricFlowRate.cs` | L180 | `/// <returns>True if the flow rate is between 0.1 and 0.5 L/s (typical for taps and showers).</returns>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/VolumetricFlowRate.cs` | L184 | `T lowerBound = T.CreateChecked(0.0001); // 0.1 L/s in m¬≥/s` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/VolumetricFlowRate.cs` | L185 | `T upperBound = T.CreateChecked(0.0005); // 0.5 L/s in m¬≥/s` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/VolumetricFlowRate.cs` | L194 | `T threshold = T.CreateChecked(0.001); // 1 L/s in m¬≥/s` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/ReynoldsNumber.cs` | L164 | `/// - Turbulent smooth: Blasius equation f = 0.316/Re^0.25 (for Re &lt; 100,000)` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/ReynoldsNumber.cs` | L184 | `return T.CreateChecked(0.316) / T.CreateChecked(Math.Pow(double.CreateChecked(re), 0.25));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/ReynoldsNumber.cs` | L190 | `return T.One / T.CreateChecked(Math.Pow((2.0 * double.CreateChecked(logRe)) - 0.8, 2));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/ReynoldsNumber.cs` | L196 | `T term1 = roughness / T.CreateChecked(3.7);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/ReynoldsNumber.cs` | L197 | `T term2 = T.CreateChecked(2.51) / re;` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/ReynoldsNumber.cs` | L199 | `return T.CreateChecked(0.25) / (logTerm * logTerm);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/ReynoldsNumber.cs` | L206 | `T turbulentF = T.CreateChecked(0.316) / T.CreateChecked(Math.Pow(double.CreateChecked(re), 0.25));` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/ReynoldsNumber.cs` | L213 | `/// <returns>True if the value is in the typical range for sphere flow (0.1 to 200,000).</returns>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/ReynoldsNumber.cs` | L217 | `T lowerBound = T.CreateChecked(0.1);` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/MassFlowRate.cs` | L183 | `T threshold = T.CreateChecked(1.0); // 1 kg/s` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/MassFlowRate.cs` | L188 | `/// <returns>True if the mass flow rate is less than 0.1 kg/s.</returns>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/MassFlowRate.cs` | L192 | `T threshold = T.CreateChecked(0.1); // 0.1 kg/s` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/MassFlowRate.cs` | L197 | `/// <returns>True if the mass flow rate is between 0.001 and 0.1 kg/s.</returns>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/MassFlowRate.cs` | L201 | `T lowerBound = T.CreateChecked(0.001); // 0.001 kg/s` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/MassFlowRate.cs` | L202 | `T upperBound = T.CreateChecked(0.1);   // 0.1 kg/s` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/KinematicViscosity.cs` | L159 | `/// <returns>True if the value is close to water's kinematic viscosity (‚âà 1.0 √ó 10‚Åª‚Å∂ m¬≤/s at 20¬∞C).</returns>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/KinematicViscosity.cs` | L170 | `/// <returns>True if the value is close to air's kinematic viscosity (‚âà 1.5 √ó 10‚Åª‚Åµ m¬≤/s at 20¬∞C).</returns>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/BulkModulus.cs` | L148 | `/// <returns>True if the value is close to water's bulk modulus (‚âà 2.2 GPa at 20¬∞C).</returns>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/BulkModulus.cs` | L152 | `T waterModulus = T.CreateChecked(2.2e9); // 2.2 GPa` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/FluidDynamics/BulkModulus.cs` | L153 | `T tolerance = T.CreateChecked(0.5e9);     // ¬±0.5 GPa` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Core/Units.cs` | L35 | `/// <summary>Centimeter - 0.01 meters.</summary>` |
| `file:///c%3A/dev/ktsu-dev/Semantics/Semantics/Quantities/Core/Units.cs` | L38 | `/// <summary>Millimeter - 0.001 meters.</summary>` |

</details>

---



---

I can see there are some hard-coded conversion factors that should be moved to the physical constants. Let me check the current state of the constants file to see what's available:

---

Read file: Semantics/Quantities/Core/PhysicalConstants.cs

---



---

Looking at the hard-coded values found, I can see several conversion factors that could be moved to the constants file. Let me add the missing conversion factors to the PhysicalConstants:

---



---



---

Now let me add the corresponding Generic helper methods:

---



---



---

Now let me update some of the quantity implementations to use these new constants. Let me start with the thermal resistance:

---



---



---

_**User**_

try again

---

_**Assistant**_



---



---



---

Now let me continue updating other files to use the centralized constants. Let me update the ThermalExpansion file:

---



---



---



---

Now let me update the SpecificHeat file to use constants:

---



---



---



---

Let me update the HeatTransferCoefficient file:

---



---



---



---



---

Now let me update HeatCapacity and Entropy files:

---



---



---



---



---



---

Now let me update the Entropy file:

---



---



---



---



---



---



---

Now let me update the optical and nuclear domain files. Let me update the Illuminance file:

---



---



---

Now let me update the Luminance file:

---



---



---

Now let me update the nuclear domain files. Let me update AbsorbedDose:

---



---



---

Now let me update EquivalentDose:

---



---



---

Now let me update the Exposure file:

---



---



---

Great! I've successfully updated many of the hard-coded conversion factors to use centralized constants. Now let me move on to **Priority 3: Enhanced Testing Strategy**. Let me create comprehensive integration tests that use quantities from multiple domains together:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.Semantics.Test;
+ 
+ using Microsoft.VisualStudio.TestTools.UnitTesting;
+ 
+ /// <summary>
+ /// Integration tests demonstrating quantities from multiple physics domains working together.
+ /// </summary>
+ [TestClass]
+ public class IntegrationTests
+ {
+ 	private const double Tolerance = 1e-10;
+ 
+ 	/// <summary>
+ 	/// Tests ideal gas law using thermal, chemical, and mechanical quantities.
+ 	/// PV = nRT demonstration.
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void IdealGasLaw_CombinesThreeDomainsCorrectly()
+ 	{
+ 		// Arrange - Standard conditions
+ 		var pressure = Pressure<double>.FromPascals(101325.0);        // 1 atm (Mechanical)
+ 		var volume = Volume<double>.FromCubicMeters(0.0224);          // 22.4 L (Mechanical) 
+ 		var temperature = Temperature<double>.FromKelvin(273.15);      // 0¬∞C (Thermal)
+ 		var gasConstant = PhysicalConstants.Generic.GasConstant<double>();
+ 
+ 		// Act - Calculate amount of substance using ideal gas law: n = PV/RT
+ 		var calculatedMoles = (pressure * volume) / (gasConstant * temperature);
+ 		var expectedMoles = AmountOfSubstance<double>.FromMoles(1.0); // Should be ~1 mole at STP
+ 
+ 		// Assert
+ 		Assert.AreEqual(expectedMoles.Value, calculatedMoles.Value, 0.01, 
+ 			"Ideal gas law should predict approximately 1 mole at STP");
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests electromagnetic energy calculations combining electrical and optical domains.
+ 	/// E = hf for photons and electrical power relationships.
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void ElectromagneticEnergy_CombinesElectricalAndOpticalDomains()
+ 	{
+ 		// Arrange - Green light LED
+ 		var frequency = Frequency<double>.FromHertz(5.45e14);         // Green light ~550nm (Acoustic)
+ 		var voltage = Voltage<double>.FromVolts(3.3);                 // LED forward voltage (Electrical)
+ 		var current = ElectricCurrent<double>.FromAmperes(0.02);      // 20mA LED current (Electrical)
+ 
+ 		// Act - Calculate photon energy and electrical power
+ 		var photonEnergy = Frequency<double>.GetPhotonEnergy(frequency);  // E = hf
+ 		var electricalPower = voltage * current;                          // P = VI
+ 
+ 		// Assert - Verify reasonable values
+ 		Assert.IsTrue(photonEnergy.Value > 0, "Photon energy should be positive");
+ 		Assert.AreEqual(0.066, electricalPower.Value, 0.001, "Electrical power should be 66mW");
+ 		
+ 		// Green light photon should be around 2.25 eV = 3.6e-19 J
+ 		Assert.IsTrue(photonEnergy.Value > 3e-19 && photonEnergy.Value < 4e-19, 
+ 			"Green light photon energy should be around 3.6e-19 J");
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests acoustic-mechanical relationships using sound in different media.
+ 	/// Combines acoustic, mechanical, and fluid dynamics domains.
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void SoundPropagation_CombinesAcousticMechanicalAndFluidDomains()
+ 	{
+ 		// Arrange - Sound in air
+ 		var frequency = Frequency<double>.FromHertz(1000.0);          // 1 kHz tone (Acoustic)
+ 		var airDensity = Density<double>.FromKilogramsPerCubicMeter(1.225); // Air density (Mechanical)
+ 		var soundSpeed = SoundSpeed<double>.FromMetersPerSecond(343.0);     // Sound speed in air (Acoustic)
+ 
+ 		// Act - Calculate acoustic properties
+ 		var wavelength = soundSpeed / frequency;                      // Œª = v/f
+ 		var acousticImpedance = AcousticImpedance<double>.FromDensityAndSoundSpeed(airDensity, soundSpeed); // Z = œÅc
+ 
+ 		// Assert
+ 		Assert.AreEqual(0.343, wavelength.Value, 0.001, "1 kHz wavelength in air should be ~34.3 cm");
+ 		Assert.IsTrue(acousticImpedance.Value > 400 && acousticImpedance.Value < 450, 
+ 			"Air acoustic impedance should be around 415 kg/(m¬≤¬∑s)");
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests nuclear decay and energy release combining nuclear and thermal domains.
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void NuclearDecay_CombinesNuclearAndThermalDomains()
+ 	{
+ 		// Arrange - Radioactive source
+ 		var initialActivity = RadioactiveActivity<double>.FromBecquerels(1000.0); // 1000 Bq (Nuclear)
+ 		var halfLife = Time<double>.FromSeconds(3600.0);                         // 1 hour half-life (Mechanical)
+ 		var time = Time<double>.FromSeconds(7200.0);                             // 2 hours elapsed (Mechanical)
+ 
+ 		// Act - Calculate decay
+ 		var remainingActivity = RadioactiveActivity<double>.AfterTime(initialActivity, halfLife, time);
+ 		var decayedAtoms = initialActivity.Value - remainingActivity.Value; // Simplified decay count
+ 
+ 		// Convert to thermal energy (simplified - each decay releases ~1 MeV = 1.6e-13 J)
+ 		var energyPerDecay = Energy<double>.FromJoules(1.6e-13);
+ 		var totalThermalEnergy = Energy<double>.Create(decayedAtoms * energyPerDecay.Value);
+ 
+ 		// Assert
+ 		Assert.AreEqual(250.0, remainingActivity.Value, 1.0, 
+ 			"Activity should be 1/4 original after 2 half-lives");
+ 		Assert.IsTrue(totalThermalEnergy.Value > 0, "Thermal energy should be released from decay");
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests fluid dynamics and thermodynamics in heat transfer.
+ 	/// Combines fluid dynamics, thermal, and mechanical domains.
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void HeatTransferInFlowingFluid_CombinesMultipleDomains()
+ 	{
+ 		// Arrange - Hot water flowing through pipe
+ 		var fluidTemp = Temperature<double>.FromCelsius(80.0);         // Hot water (Thermal)
+ 		var ambientTemp = Temperature<double>.FromCelsius(20.0);       // Ambient temperature (Thermal)
+ 		var flowRate = VolumetricFlowRate<double>.FromLitersPerSecond(2.0); // 2 L/s flow (Fluid Dynamics)
+ 		var waterDensity = Density<double>.FromKilogramsPerCubicMeter(1000.0); // Water density (Mechanical)
+ 		var specificHeat = SpecificHeat<double>.FromJoulesPerKilogramKelvin(4186.0); // Water specific heat (Thermal)
+ 
+ 		// Act - Calculate mass flow rate and thermal power
+ 		var massFlowRate = MassFlowRate<double>.FromDensityAndVolumetricFlow(waterDensity, flowRate);
+ 		var tempDifference = fluidTemp - ambientTemp;
+ 		var thermalPower = Power<double>.Create(massFlowRate.Value * specificHeat.Value * tempDifference.Value);
+ 
+ 		// Assert
+ 		Assert.AreEqual(2.0, massFlowRate.Value, 0.01, "Mass flow rate should be 2 kg/s for water");
+ 		Assert.IsTrue(thermalPower.Value > 500000 && thermalPower.Value < 600000, 
+ 			"Thermal power should be around 500 kW");
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests chemical reaction kinetics with thermal effects.
+ 	/// Combines chemical and thermal domains.
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void ChemicalReactionKinetics_CombinesChemicalAndThermalDomains()
+ 	{
+ 		// Arrange - Arrhenius equation parameters
+ 		var preExponentialFactor = 1e12; // A factor in s‚Åª¬π
+ 		var activationEnergy = ActivationEnergy<double>.FromJoulesPerMole(50000.0); // 50 kJ/mol (Chemical)
+ 		var lowTemp = Temperature<double>.FromCelsius(25.0);           // Room temperature (Thermal)
+ 		var highTemp = Temperature<double>.FromCelsius(100.0);         // Elevated temperature (Thermal)
+ 
+ 		// Act - Calculate rate constants at different temperatures
+ 		var lowTempRate = RateConstant<double>.FromArrheniusEquation(preExponentialFactor, activationEnergy, lowTemp);
+ 		var highTempRate = RateConstant<double>.FromArrheniusEquation(preExponentialFactor, activationEnergy, highTemp);
+ 
+ 		// Assert - Higher temperature should give higher rate constant
+ 		Assert.IsTrue(highTempRate.Value > lowTempRate.Value, 
+ 			"Rate constant should increase with temperature");
+ 		
+ 		// Rate should increase significantly (exponentially) with temperature
+ 		double rateRatio = highTempRate.Value / lowTempRate.Value;
+ 		Assert.IsTrue(rateRatio > 5.0, 
+ 			"Rate constant should increase substantially with 75¬∞C temperature increase");
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests mechanical energy conversion with electrical generation.
+ 	/// Combines mechanical and electrical domains.
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void MechanicalToElectricalConversion_CombinesMechanicalAndElectricalDomains()
+ 	{
+ 		// Arrange - Generator parameters
+ 		var torque = Torque<double>.FromNewtonMeters(100.0);          // Generator torque (Mechanical)
+ 		var angularVelocity = AngularVelocity<double>.FromRadiansPerSecond(150.0); // ~1430 RPM (Mechanical)
+ 		var efficiency = 0.85; // 85% efficiency
+ 
+ 		// Act - Calculate mechanical and electrical power
+ 		var mechanicalPower = torque * angularVelocity;               // P = œÑœâ
+ 		var electricalPower = Power<double>.Create(mechanicalPower.Value * efficiency);
+ 
+ 		// For a 3-phase generator at 400V line-to-line
+ 		var voltage = Voltage<double>.FromVolts(400.0);               // Line voltage (Electrical)
+ 		var current = electricalPower / (voltage * Math.Sqrt(3));    // 3-phase current (simplified)
+ 
+ 		// Assert
+ 		Assert.AreEqual(15000.0, mechanicalPower.Value, 0.1, "Mechanical power should be 15 kW");
+ 		Assert.AreEqual(12750.0, electricalPower.Value, 1.0, "Electrical power should be 12.75 kW");
+ 		Assert.IsTrue(current.Value > 18 && current.Value < 19, 
+ 			"3-phase current should be around 18.4 A");
+ 	}
+ 
+ 	/// <summary>
+ 	/// Tests optical fiber transmission with electrical and optical domains.
+ 	/// </summary>
+ 	[TestMethod]
+ 	public void OpticalFiberTransmission_CombinesOpticalAndElectricalDomains()
+ 	{
+ 		// Arrange - Fiber optic system
+ 		var laserPower = Power<double>.FromWatts(0.001);              // 1 mW laser (Electrical)
+ 		var fiberLength = Length<double>.FromKilometers(10.0);        // 10 km fiber (Mechanical)
+ 		var attenuationPerKm = 0.2; // 0.2 dB/km attenuation
+ 		var coreRefractiveIndex = RefractiveIndex<double>.Create(1.46); // Silica core (Optical)
+ 		var claddingRefractiveIndex = RefractiveIndex<double>.Create(1.45); // Silica cladding (Optical)
+ 
+ 		// Act - Calculate numerical aperture and received power
+ 		var numericalAperture = Math.Sqrt(Math.Pow(coreRefractiveIndex.Value, 2) - 
+ 		                                  Math.Pow(claddingRefractiveIndex.Value, 2));
+ 		
+ 		// Calculate power loss due to attenuation
+ 		var totalAttenuation = attenuationPerKm * fiberLength.Value;
+ 		var powerLossFactor = Math.Pow(10, -totalAttenuation / 10); // Convert dB to linear
+ 		var receivedPower = Power<double>.Create(laserPower.Value * powerLossFactor);
+ 
+ 		// Assert
+ 		Assert.IsTrue(numericalAperture > 0.1 && numericalAperture < 0.2, 
+ 			"Numerical aperture should be around 0.17");
+ 		Assert.IsTrue(receivedPower.Value < laserPower.Value, 
+ 			"Received power should be less than transmitted power");
+ 		Assert.IsTrue(receivedPower.Value > 0.0006, 
+ 			"Should receive more than 0.6 mW after 10 km with 0.2 dB/km loss");
+ 	}
+ } 
```

---

Now let me run the tests to make sure they work correctly:

---

```bash
cd /c/dev/ktsu-dev/Semantics && dotnet test --filter "IntegrationTests" --verbosity normal
```

```
C:\dev\ktsu-dev\Semantics>cd /c/dev/ktsu-dev/Semantics && dotnet test --filter "IntegrationTests" --verbosity normal
Microsoft Windows [Version 10.0.26100.4351]
(c) Microsoft Corporation. All rights reserved.

C:\dev\ktsu-dev\Semantics>cd /c/dev/ktsu-dev/Semantics && dotnet test --filter "IntegrationTests" --verbosity normal
The system cannot find the path specified.

C:\dev\ktsu-dev\Semantics>





















C:\dev\ktsu-dev\Semantics>
```

---



---

```bash
dotnet test --filter "IntegrationTests" --verbosity normal
```

```
C:\dev\ktsu-dev\Semantics>dotnet test --filter "IntegrationTests" --verbosity normal

                                                                                                                 (0.1s)
Restore complete (3.1s)
  Semantics succeeded (3.3s) ‚Üí Semantics\bin\Debug\net9.0\ktsu.Semantics.dll
```

---



---

```bash
dotnet test Semantics.Test --filter "TestCategory=Integration" --verbosity normal
```

```

Restore complete (1.3s)
  C:\dev\ktsu-dev\Semantics\Semantics.Test\Semantics.Test.csproj                                         Restore (1.3s)
```

---

Let me try running all tests to see if our integration tests are working:

---

```bash
dotnet test Semantics.Test --verbosity normal
```

```

Restore complete (1.3s)
  Semantics succeeded (0.5s) ‚Üí Semantics\bin\Debug\net9.0\ktsu.Semantics.dll
  Semantics.Test failed with 54 error(s) (1.2s)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(31,26): error CS0019: Operator '*' cannot be applied to operands of type 'Pressure<double>' and 'Volume<double>'     
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(48,17): error CS0103: The name 'Voltage' does not exist in the current context
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(98,55): error CS0117: 'RadioactiveActivity<double>' does not contain a definition for 'AfterTime'
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(126,43): error CS0117: 'MassFlowRate<double>' does not contain a definition for 'FromDensityAndVolumetricFlow'       
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(145,51): error CS0117: 'ActivationEnergy<double>' does not contain a definition for 'FromJoulesPerMole'
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(176,25): error CS0019: Operator '*' cannot be applied to operands of type 'Torque<double>' and 'AngularVelocity<doubl
e>'
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(180,17): error CS0103: The name 'Voltage' does not exist in the current context
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(198,36): error CS0117: 'Length<double>' does not contain a definition for 'FromKilometers'
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(25,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(26,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(27,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(28,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(32,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(31,25): error IDE0047: Parentheses can be removed (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/styl
e-rules/ide0047)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(47,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(49,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(52,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(60,17): error IDE0078: Use pattern matching (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rule
s/ide0078)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(72,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(73,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(74,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(77,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(78,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(82,17): error IDE0078: Use pattern matching (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rule
s/ide0078)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(93,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(94,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(95,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analys
is/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(102,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(119,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(120,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(121,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(122,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(123,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(127,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(132,17): error IDE0078: Use pattern matching (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rul
es/ide0078)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(144,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(146,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(147,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(150,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(151,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(171,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(172,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(173,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(186,17): error IDE0078: Use pattern matching (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rul
es/ide0078)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(197,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(199,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(200,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(201,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(204,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(209,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(210,3): error IDE0008: Use explicit type instead of 'var' (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0008)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(213,17): error IDE0078: Use pattern matching (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rul
es/ide0078)
-rules/ca1823)
    C:\dev\ktsu-dev\Semantics\Semantics.Test\IntegrationTests.cs(205,3): error IDE0055: Fix formatting (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0
055)

Build failed with 54 error(s) in 5.0s

C:\dev\ktsu-dev\Semantics>
```

---



---

I can see there are some compilation errors in the integration tests. Let me fix these issues by updating the test to use the correct available methods. Let me check what methods are actually available:

---

Could not find file 'Semantics/Quantities/Electrical/Voltage.cs' in the workspace.

---

<details>
            <summary>Listed directory Semantics/Quantities/Electrical ‚Ä¢ **11** results</summary>
        
| Name |
|-------|
| üìÑ `ElectricCapacitance.cs` |
| üìÑ `ElectricCharge.cs` |
| üìÑ `ElectricResistance.cs` |
| üìÑ `ElectricPotential.cs` |
| üìÑ `ElectricCurrent.cs` |
| üìÑ `ElectricPowerDensity.cs` |
| üìÑ `ImpedanceAC.cs` |
| üìÑ `ElectricField.cs` |
| üìÑ `ElectricConductivity.cs` |
| üìÑ `Permittivity.cs` |
| üìÑ `ElectricFlux.cs` |

</details>

---





---

