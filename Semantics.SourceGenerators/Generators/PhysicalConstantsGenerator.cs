// Copyright (c) ktsu.dev
// All rights reserved.
// Licensed under the MIT license.

namespace Semantics.SourceGenerators;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Semantics.SourceGenerators.Models;

/// <summary>
/// Source generator that creates the PhysicalConstants.cs file from JSON metadata.
/// </summary>
[Generator]
public class PhysicalConstantsGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find the domains metadata JSON file
		IncrementalValuesProvider<string> metadataFiles = context.AdditionalTextsProvider
			.Where(file => file.Path.EndsWith("domains.json", System.StringComparison.InvariantCulture))
			.Select((file, cancellationToken) => file.GetText(cancellationToken)?.ToString() ?? "")
			.Where(content => !string.IsNullOrEmpty(content));

		// Generate code from metadata
		context.RegisterSourceOutput(metadataFiles, (ctx, jsonContent) =>
		{
			if (string.IsNullOrEmpty(jsonContent))
			{
				return;
			}

			try
			{
				JsonSerializerOptions options = new()
				{
					PropertyNameCaseInsensitive = true
				};

				DomainsMetadata metadata = JsonSerializer.Deserialize<DomainsMetadata>(jsonContent, options) ??
					throw new JsonException("Failed to deserialize units metadata");

				if (metadata?.Domains == null)
				{
					return;
				}

				// Generate the PhysicalConstants.cs source code
				string sourceCode = GeneratePhysicalConstantsClass(metadata);

				// Add the generated source to the compilation
				ctx.AddSource("PhysicalConstants.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
			}
			catch (JsonException ex)
			{
				// Report JSON parsing error
				DiagnosticDescriptor descriptor = new(
					"CONST001",
					"JSON parsing error",
					"Failed to parse domains metadata JSON: {0}",
					"SourceGenerator",
					DiagnosticSeverity.Error,
					isEnabledByDefault: true);

				ctx.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, ex.Message));
			}
		});
	}

	private static string GeneratePhysicalConstantsClass(DomainsMetadata metadata)
	{
		StringBuilder builder = new();

		builder.AppendLine("// Copyright (c) ktsu.dev");
		builder.AppendLine("// All rights reserved.");
		builder.AppendLine("// Licensed under the MIT license.");
		builder.AppendLine("// <auto-generated />");
		builder.AppendLine();
		builder.AppendLine("namespace ktsu.Semantics;");
		builder.AppendLine();
		builder.AppendLine("using System.Globalization;");
		builder.AppendLine("using System.Numerics;");
		builder.AppendLine("using ktsu.PreciseNumber;");
		builder.AppendLine();
		builder.AppendLine("/// <summary>");
		builder.AppendLine("/// Provides fundamental physical constants used throughout the Semantics library.");
		builder.AppendLine("/// All values are based on the 2019 redefinition of SI base units and CODATA 2018 values.");
		builder.AppendLine("/// </summary>");
		builder.AppendLine("public static class PhysicalConstants");
		builder.AppendLine("{");

		// Generate each category
		foreach (Domain category in metadata.Domains.OrderBy(c => c.Name))
		{
			GenerateConstantsCategory(builder, category);
		}

		// Generate the Generic helper class if it has constants
		List<ConstantDefinition> allConstants = [.. metadata.Domains.SelectMany(c => c.Constants)];
		if (allConstants.Count != 0)
		{
			GenerateGenericHelpersClass(builder, allConstants);
		}

		builder.AppendLine("}");
		return builder.ToString();
	}

	private static void GenerateConstantsCategory(StringBuilder builder, Domain category)
	{
		builder.AppendLine();
		builder.AppendLine($"\t/// <summary>");
		builder.AppendLine($"\t/// {category.Description}");
		builder.AppendLine($"\t/// </summary>");
		builder.AppendLine($"\tpublic static class {category.Name}");
		builder.AppendLine("\t{");

		foreach (ConstantDefinition constant in category.Constants.OrderBy(c => c.Name))
		{
			GenerateConstant(builder, constant, "\t\t");
		}

		builder.AppendLine("\t}");
	}

	private static void GenerateConstant(StringBuilder builder, ConstantDefinition constant, string indent)
	{
		// Generate XML documentation
		builder.AppendLine($"{indent}/// <summary>{constant.Description}</summary>");

		// Parse the high-precision value and generate the constant declaration
		builder.AppendLine($"{indent}public static readonly PreciseNumber {constant.Name} = PreciseNumber.Parse(\"{constant.Value}\", CultureInfo.InvariantCulture);");
		builder.AppendLine();
	}

	private static void GenerateGenericHelpersClass(StringBuilder builder, List<ConstantDefinition> allConstants)
	{
		builder.AppendLine();
		builder.AppendLine("\t/// <summary>");
		builder.AppendLine("\t/// Helper methods to get constants as generic numeric types");
		builder.AppendLine("\t/// </summary>");
		builder.AppendLine("\tpublic static class Generic");
		builder.AppendLine("\t{");

		foreach (ConstantDefinition? constant in allConstants.OrderBy(c => c.Name))
		{
			GenerateGenericHelper(builder, constant);
		}

		builder.AppendLine("\t}");
	}

	[System.Diagnostics.CodeAnalysis.SuppressMessage("Globalization", "CA1308:Normalize strings to uppercase", Justification = "<Pending>")]
	private static void GenerateGenericHelper(StringBuilder builder, ConstantDefinition constant)
	{
		// Generate XML documentation
		builder.AppendLine($"\t\t/// <summary>Gets {constant.Description.ToLowerInvariant()} as type T</summary>");

		// Generate the generic method
		builder.AppendLine($"\t\tpublic static T {constant.Name}<T>() where T : struct, INumber<T> => T.CreateChecked({constant.Name});");
		builder.AppendLine();
	}
}
